# Assignment Documentation

## Overview
This repository provisions an Amazon EKS cluster (networking, IAM, control plane, and managed node group) via Terraform, deploys a sample NGINX workload with raw Kubernetes manifests, and exposes the same workload through Argo CD for GitOps-based management. Use this README as the single source of truth for setup, verification, screenshot collection, and teardown.

## Repository Layout
| Path | Description |
| --- | --- |
| `Terraform/` | Infrastructure as Code (VPC, IAM, EKS cluster, managed node group). |
| `Terraform/modules/` | Reusable modules (`vpc`, `iam`, `cluster`, `node_group`). |
| `manifests/` | Plain Kubernetes manifests (`nginx-deployment.yaml`, `nginx-service.yaml`). |
| `argocd/application.yaml` | Argo CD `Application` manifest referencing the same workload. |
| `assignment scrrenshots/` | Place verification screenshots here before submission. |

## Prerequisites
- AWS account with credentials configured locally (`aws configure` or exported env vars).
- Terraform ≥ 1.6 and AWS provider plugins (auto-installed via `terraform init`).
- `kubectl` and an updated kubeconfig (generated by `aws eks update-kubeconfig` after the cluster is up).
- Argo CD CLI/web UI if you plan to sync via GitOps (optional but recommended).

## Terraform Workflow
```bash
cd Terraform
terraform init
terraform plan -lock=false
terraform apply -lock=false   # confirm when prompted
```

- Variables live in `Terraform/variables.tf`; override with `terraform.tfvars` if needed.
- The VPC module now creates multiple public/private subnets spread across AZs to satisfy EKS requirements.
- Managed node groups currently use the public subnets for outbound internet access. If you prefer private subnets, add NAT gateways/routes first.

### Post-Apply
1. Update kubeconfig:  
   `aws eks update-kubeconfig --name appscrip_eks_cluster --region us-west-2`
2. Verify nodes/pods:  
   `kubectl get nodes`, `kubectl get pods -n default`
3. Collect screenshots (see below) and store PNG/JPEG files inside `assignment scrrenshots/`.

## Workload Deployment
### Option A – Raw Manifests
```bash
kubectl apply -f manifests/nginx-deployment.yaml
kubectl apply -f manifests/nginx-service.yaml
kubectl get svc nginx-service
```

### Option B – Argo CD
```bash
kubectl apply -n argocd -f argocd/application.yaml
# Sync via Argo CD UI/CLI
```

## Screenshot Guidance
Capture proof points (examples):
1. Terraform apply output showing successful resource creation.
2. AWS console snippets (EKS cluster, node group, subnets).
3. `kubectl get nodes` and `kubectl get svc` results.
Save files in `assignment scrrenshots/` with meaningful names (e.g., `01-terraform-apply.png`).

## Teardown
To avoid ongoing costs:
```bash
cd Terraform
terraform destroy -lock=false
```
Ensure Argo CD applications and Kubernetes workloads are removed before destroying the cluster, or Terraform may fail while deleting node groups.

## Submission Checklist
1. All screenshots stored under `assignment scrrenshots/`.
2. This README updated/committed.
3. Run `terraform destroy` and mention in your email/report that the infrastructure was deleted to minimize cost.
4. Remove transient/unwanted files (e.g., `.terraform/`, state backups) before pushing to GitHub.
5. Push to your repository and share the link, along with the list of completed tasks and the deletion note above.